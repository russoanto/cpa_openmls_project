# MLS
## Protocol Overview
MLS consente ai client di formare gruppi all'interno dei quali comunicare in modo sicuro. Ad esempio, un gruppo di utenti può utilizzare i client sui propri telefoni o laptop per unirsi a un gruppo e comunicare tra loro. Un gruppo può essere piccolo come due client (ad esempio, per la semplice messaggistica da persona a persona) o grande come centinaia di migliaia. Un client che fa parte di un gruppo è un membro di quel gruppo. Quando i gruppi cambiano i membri e le proprietà dei gruppi o dei membri, passano da un'epoca all'altra e lo stato crittografico del gruppo si evolve. Il gruppo è rappresentato come un albero, che rappresenta i membri come le foglie di un albero. Viene utilizzato per crittografare in modo efficiente i sottoinsiemi dei membri. Ogni membro ha uno stato chiamato oggetto LeafNode che contiene l'identità, le credenziali e le capacità del cliente. Nell'evoluzione da un'epoca all'altra vengono utilizzati diversi messaggi. 
- Un messaggio **Proposal** propone una modifica da apportare nell'epoca successiva, come l'aggiunta o la rimozione di un membro. 
- Un messaggio di **Commit** dà inizio a una nuova epoca istruendo i membri del gruppo a implementare un insieme di proposte. 
    - Le proposte e i commit sono chiamati collettivamente messaggi *Handshake*. 
- Un **KeyPackage** fornisce le chiavi che possono essere utilizzate per aggiungere il client a un gruppo, tra cui il suo LeafNode e la chiave di firma. 
- Un messaggio di **welcome** fornisce al nuovo membro del gruppo le informazioni per inizializzare il suo stato per l'epoca in cui è stato aggiunto. Naturalmente la maggior parte delle applicazioni (ma non tutte) utilizza MLS per inviare messaggi di gruppo crittografati. 
- Un **Application message** è un messaggio MLS con un payload applicativo arbitrario.
- Infine, un **PublicMessage** contiene un messaggio di Handshake MLS protetto dall'integrità
- **PrivateMessage** contiene un messaggio di Handshake o di applicazione confidenziale e protetto dall'integrità.
## Cryptographic State and Evolution
LO stato crittografico del protocollo MLS è diviso in 3 aree di responsabilità:

![[Cryptographic State and Evolution.png]]
- **Un albero a ratchet** che rappresenta i membri del gruppo, fornendo loro un modo per autenticarsi reciprocamente e crittografare in modo efficiente i messaggi per sottogruppi del gruppo. Ogni epoca ha un albero a ratchet distinto.
- Un **key schedule** che descrive la catena di derivazioni delle chiavi utilizzate per passare da un'epoca all'altra (principalmente utilizzando l'init_secret e l'epoch_secret), così come la derivazione di una varietà di altri segreti.

| Label            | Secret                | Purpose                                                                                             |
| ---------------- | --------------------- | --------------------------------------------------------------------------------------------------- |
| "sender data"    | `sender_data_secret`  | Deriving keys to encrypt sender data                                                                |
| "encryption"     | `encryption_secret`   | is used to initialize the secret tree for the epoch                                                 |
| "exporter"       | `exporter_secret`     | consente ad altri protocolli di sfruttare MLS come scambio generico di chiavi di gruppo autenticate |
| "external"       | `external_secret`     | Deriving the external init key                                                                      |
| "confirm"        | `confirmation_key`    | Computing the confirmation MAC for an epoch                                                         |
| "membership"     | `membership_key`      | Computing the membership MAC for a PublicMessage                                                    |
| "resumption"     | `resumption_psk`      | Proving membership in this epoch (via a PSK injected later)                                         |
| "authentication" | `epoch_authenticator` | Confirming that two clients have the same view of the group                                         |
Ogni nuova epoca viene avviata con un messaggio Commit. Il Commit istruisce i membri esistenti del gruppo ad aggiornare la loro visione dell'albero a ratchet applicando un insieme di Proposals e utilizza l'albero a ratchet aggiornato per distribuire nuova entropia al gruppo. Questa nuova entropia viene fornita solo ai membri della nuova epoca e non ai membri che sono stati rimossi. I Commit mantengono quindi la proprietà che il segreto dell'epoca rimane confidenziale per i membri dell'epoca corrente. Per ogni Commit che aggiunge uno o più membri al gruppo, ci sono uno o più messaggi di Welcome corrispondenti. Ogni messaggio di Welcome fornisce ai nuovi membri le informazioni necessarie per inizializzare la loro visione del piano delle chiavi e dell'albero a ratchet, in modo che queste visioni siano allineate con quelle degli altri membri del gruppo in questa epoca.

## Example Protocol execution
Ci sono 3 operazioni principali nella vita di un gruppo:
- **Aggiunta di un membro**, iniziata da un membro attuale
- **Aggiornamento di una chiave** che rappresenta un membro dell'albero
- **Rimozione di un membro**
Ognuna di queste operazioni viene **proposta** mandando un messaggio del corrispondente tipo (aggiunta, aggiornamento e rimozione). Lo stato del gruppo, tuttavia, non viene modificato fino a quando non viene inviato un messaggio di **Commit** per fornire al gruppo una nuova entropia. Quando un gruppo viene creato per la prima volta, si dice che si trova nell'epoca 0. Successivamente, ogni modifica al gruppo incrementa il numero dell'epoca. In ogni epoca, l'attuale appartenenza al gruppo può essere vista come un array, dove alcune voci possono essere vuote e ogni voce non vuota contiene le credenziali e le chiavi pubbliche di un membro del gruppo.
![[mls-array.png]]
Per convenzione, il creatore del gruppo si trova all'indice 0. Quando si aggiunge un nuovo membro, i suoi dati vengono collocati al primo indice vuoto e, se tutti gli indici sono occupati, estendendo la fine dell'array. Rimuovendo un membro, il suo indice viene svuotato. L'aggiornamento della credenziale o della chiave di un membro modifica il valore memorizzato nel suo indice. L'array dei membri rappresenta uno snapshot dell'appartenenza al gruppo in una particolare epoca e può essere utilizzato per comprendere gli obiettivi di sicurezza di MLS. In ogni epoca, ci aspettiamo che tutti i membri del gruppo siano d'accordo sull'array di membri attuale e che possano inviare e ricevere messaggi di gruppo che saranno visibili solo ai membri attuali.
## Threat Model
Le principali minacce ai messaggi inviati tramite MLS sono rappresentate da network attackers, da server maligni e da membri del gruppo compromessi, il cui stato e le cui chiavi crittografiche sono state ottenute dall'avversario.
## Security Goal
MLS mira a fornire una serie di garanzie di sicurezza, che coprono l'autenticazione e le garanzie di riservatezza in misura diversa in diversi scenari.
- **Message Confidentiality**: Se un client C invia un messaggio M nell'epoca E del gruppo G e C ritiene che i membri di G in E siano C0,...,Cn, allora M è tenuto segreto dall'avversario finché nessuno di questi membri è compromesso.
- **Forward Secrecy**: Se un client C invia (o riceve) un messaggio M nell'epoca E del gruppo G, qualsiasi compromissione di C dopo questo punto non influisce sulla riservatezza di M
- **Message Authentication**: Se un client C accetta un messaggio M nell'epoca E del gruppo G, e se C ritiene che i membri di G in E siano C0,...,Cn, e se nessuno di questi membri è compromesso al momento della ricezione, allora M deve essere stato inviato da uno di questi membri del gruppo per il gruppo G nell'epoca E.
- **Sender Authentication**:Se un client C accetta un messaggio M apparentemente inviato da un client C' nell'epoca E del gruppo G, e se C' non è compromesso al momento della ricezione, allora M deve essere stato inviato da C' nell'epoca E del gruppo G.
- **Membership Agreement**: Se un client C accetta un messaggio M da un client C' nell'epoca E del gruppo G, allora C e C' devono essere d'accordo sull'appartenenza di G a E
- **Post-Remove Security**: Se un client C era membro del gruppo G nell'epoca E e non lo è più nell'epoca E+1, anche se C è stato compromesso nell'epoca <= E, questo non influisce sulla riservatezza dei messaggi inviati nell'epoca >= E+1
- **Post-Update Security**:Se un client C era membro del gruppo G nell'epoca E e ha aggiornato le sue chiavi crittografiche nell'epoca E+1, anche se lo stato precedente di C nelle epoche <= E è stato compromesso, ciò non influisce sulla riservatezza dei messaggi inviati nelle epoche >= E+1
Il primo obiettivo di sicurezza veramente innovativo di MLS è l'accordo di appartenenza, che garantisce che i membri del gruppo siano d'accordo tra loro sull'appartenenza attuale. In pratica, MLS richiede un accordo ancora più forte sull'intera storia di appartenenza del gruppo e sui suoi stati crittografici. Si noti che i protocolli di gruppo attualmente in uso, come Signal Sender Keys, non prevedono un accordo di appartenenza. Gli ultimi due obiettivi riguardano la nozione di sicurezza post-compromissione (PCS) per la messaggistica di gruppo. A differenza della messaggistica a due parti, in cui è necessario spiegare la PCS in termini di situazioni ipotetiche come il furto temporaneo di un dispositivo, i gruppi richiedono una nozione più semplice di recupero dalla compromissione dopo la rimozione. Forse l'obiettivo di sicurezza più importante per MLS è che una volta che un membro è stato rimosso dal gruppo, non può più leggere o scrivere messaggi. Inoltre, MLS fornisce anche una sicurezza post-aggiornamento, proprio come i protocolli a due parti come Signal. Vale la pena notare che la maggior parte dei protocolli di messaggistica di gruppo, tra cui Signal Sender Keys, non forniscono nessuna di queste due proprietà.
## Performance Constraints
Un requisito fondamentale di MLS è che deve supportare il funzionamento asincrono. In altre parole, i membri devono essere in grado di inviare messaggi e apportare modifiche al gruppo senza richiedere che gli altri membri siano online nello stesso momento. Ciò significa che la maggior parte dei classici protocolli di scambio di chiavi di gruppo della letteratura crittografica non sono adatti a MLS. Tuttavia, progettare un protocollo asincrono semplice che soddisfi gli obiettivi di sicurezza sopra descritti non è difficile e tali protocolli sono già stati implementati in Signal, WhatsApp, Matrix, ecc. Il principale vincolo di progettazione è la scalabilità. MLS è pensato per funzionare per gruppi con migliaia di utenti, quindi i protocolli che richiedono calcoli pesanti ai mittenti o ai destinatari o messaggi di grandi dimensioni diventano impraticabili con l'aumentare delle dimensioni del gruppo. La maggior parte dei protocolli di messaggistica di gruppo attualmente in uso scalano linearmente (e a volte quadraticamente) con il numero di utenti e sono in grado di supportare solo gruppi di dimensioni comprese tra 256 e 1024 membri. Il principale collo di bottiglia è rappresentato dal numero di operazioni a chiave pubblica necessarie per l'aggiunta o l'aggiornamento dei membri. Il requisito dichiarato nello statuto dell'MLS è che i requisiti delle risorse debbano scalare linearmente o sub-linearmente con le dimensioni del gruppo.
## The MLS Approach: TreeSync, TreeKEM, TreeDEM
Il protocollo MLS raggiunge i suoi obiettivi di performance e sicurezza utilizzando alberi binari per rappresentare la struttura dei dati di gruppo e per stabilire in modo efficiente le chiavi di gruppo. In particolare, l'array di membri raffigurato sopra si trasforma in foglie di un albero binario, dove i nodi interni rappresentano sottogruppi costituiti dai membri sottostanti.
![[mls-array-tree.png]]
Ad alto livello, MLS può essere suddiviso in tre sottoprotocolli che popolano, sincronizzano e utilizzano questa struttura di dati ad albero per stabilire chiavi condivise per il gruppo e utilizzarle per la messaggistica sicura. Chiamiamo questi tre sottoprotocolli TreeSync, TreeKEM e TreeDEM. Questa decomposizione di MLS non è esplicitamente specificata nello standard.
- **TreeSync**: Gestione autenticata del gruppo Il sottoprotocollo TreeSync garantisce che tutti i membri del gruppo abbiano una visione coerente e autenticata dello stato del gruppo, compresi l'array dei membri e le chiavi memorizzate nella struttura dati ad albero MLS. TreeSync definisce tutte le operazioni di gestione del gruppo e utilizza tecniche multiple di hashing dell'albero (non dissimili dagli alberi di Merkle) e firme per garantire l'accordo di appartenenza e l'integrità dello stato del gruppo. Questo serve come precondizione essenziale per la creazione delle chiavi.
- **TreeKEM**: Il sottoprotocollo TreeKEM utilizza la struttura dei dati ad albero per generare chiavi di sottogruppo per ogni nodo interno dell'albero, compresa una chiave di gruppo per la radice che viene condivisa tra tutti i membri del gruppo nell'epoca corrente. Ogni volta che i membri del gruppo cambiano, TreeKEM genera una nuova chiave di gruppo e la trasmette in modo efficiente a tutti gli altri membri. Finché tutti i membri contribuiscono attivamente al gruppo, tutte le operazioni di TreeKEM hanno un costo proporzionale all'altezza dell'albero, cioè logaritmico rispetto alla dimensione del gruppo. Tuttavia, se solo alcuni membri contribuiscono attivamente, il costo di ogni operazione può diventare lineare rispetto alle dimensioni del gruppo.
- **TreeDEM**: Il sottoprotocollo TreeDEM utilizza le chiavi di gruppo stabilite da TreeKEM per crittografare e autenticare i messaggi applicativi inviati in ogni epoca. TreeDEM garantisce la  forward security dei messaggi applicativi, utilizzando la struttura dei dati ad albero per decidere quali chiavi derivare e quando cancellarle.
### TreeKEM
TreeKEM è un sottoprotocollo di MLS che si basa su collision-resistant hash function (**H**), un meccanismo di cifratura a chiave pubblica (pgen, penc, pdec), una funzione pseudo-random utilizzata per la key derivation function (**kdf**) e uno schema di cifratura autenticato(gen, enc, dec). 