# Why mls
Parlare del concetto di scalabilità della comunicazione, se vediamo un gruppo di comunicazione come un grafo completo allora per N dispositivi dovrei mandare ogni volta N^2. Per ovviare a questo problema è nato l'mls group che ha partorito lo standard 9420 che ha come obbiettivo:
- Comunicazione sicura
- Scalabilità efficiente
- comunicazione sincrona
- gruppi dinamici
# Protocol Overview

MLS consente ai client di formare gruppi all'interno dei quali comunicare in modo sicuro. Ad esempio, un gruppo di utenti può utilizzare i client sui propri telefoni o laptop per unirsi a un gruppo e comunicare tra loro. Un gruppo può essere piccolo come due client (ad esempio, per la semplice messaggistica da persona a persona) o grande come centinaia di migliaia. Un client che fa parte di un gruppo è un membro di quel gruppo. Quando i gruppi cambiano i membri e le proprietà dei gruppi o dei membri, passano da un'epoca all'altra e lo stato crittografico del gruppo si evolve. Il gruppo è rappresentato come un albero, che rappresenta i membri come le foglie di un albero. Viene utilizzato per crittografare in modo efficiente i sottoinsiemi dei membri. Ogni membro ha uno stato chiamato oggetto LeafNode che contiene l'identità, le credenziali e le capacità del cliente.
La funzionalità principale di MLS è lo scambio continuo di chiavi autenticate di gruppo (AKE). Come in altri protocolli di scambio di chiavi autenticate (come TLS), i partecipanti al protocollo concordano un valore segreto comune e ogni partecipante può verificare l'identità degli altri partecipanti. Tale segreto può essere utilizzato per proteggere i messaggi inviati da un partecipante al gruppo agli altri partecipanti utilizzando il livello di framing MLS o può essere esportato per essere utilizzato con altri protocolli. MLS fornisce un'AKE di gruppo nel senso che ci possono essere più di due partecipanti al protocollo e un'AKE di gruppo continua nel senso che l'insieme dei partecipanti al protocollo può cambiare nel tempo.
## Evoluzione di un epoca
I principi organizzativi fondamentali di MLS sono i gruppi e le epoche. Un gruppo rappresenta un insieme logico di client che condividono un valore segreto comune in un determinato momento. La storia di un gruppo è suddivisa in una sequenza lineare di epoche. In ogni epoca, un insieme di membri autenticati concorda un segreto d'epoca che è noto solo ai membri del gruppo in quell'epoca. L'insieme dei membri coinvolti nel gruppo può cambiare da un'epoca all'altra e MLS assicura che solo i membri dell'epoca corrente abbiano accesso al segreto dell'epoca. Dal segreto dell'epoca, i membri ricavano altri segreti condivisi per la crittografia dei messaggi, l'autenticazione dei membri del gruppo e così via.

Il creatore di un gruppo MLS crea la prima epoca del gruppo unilateralmente, senza interazioni di protocollo. Successivamente, i membri del gruppo fanno avanzare il loro stato crittografico condiviso da un'epoca all'altra attraverso lo scambio di messaggi MLS.
- Un oggetto KeyPackage descrive le capacità di un client e fornisce le chiavi che possono essere utilizzate per aggiungere il client a un gruppo.
- Un messaggio Proposal propone una modifica da effettuare nell'epoca successiva, come l'aggiunta o la rimozione di un membro.
- Un messaggio Commit dà inizio a una nuova epoca istruendo i membri del gruppo a implementare un insieme di proposte. 
- Un messaggio Welcome fornisce a un nuovo membro del gruppo le informazioni per inizializzare il suo stato per l'epoca in cui è stato aggiunto o in cui vuole aggiungersi al gruppo.

## Threats
- attaccanti di rete
- server malevoli
- compromissione di client
### Security Goals
- Confidenzialità
- Forwad security
- Message auth
- Membership agreement
- PCS

# Esempio dell'esecuzione del protocollo
 Ognuna di queste operazioni viene “proposta” inviando un messaggio del tipo corrispondente (Add / Update / Remove). Lo stato del gruppo, tuttavia, non viene modificato fino a quando non viene inviato un messaggio Commit per fornire al gruppo nuova entropia. In questa sezione, mostriamo che ogni proposta viene impegnata immediatamente, ma in casi di implementazione più avanzati, un'applicazione potrebbe raccogliere diverse proposte prima di impegnarle tutte in una volta. Nelle illustrazioni che seguono, vengono mostrati direttamente i messaggi Proposal e Commit, mentre in realtà verrebbero inviati incapsulati negli oggetti PublicMessage o PrivateMessage.
  - mostra come questi KeyPackage pre-pubblicati vengono utilizzati per creare un gruppo. Quando il client A vuole creare un gruppo con i client B e C, per prima cosa inizializza uno stato di gruppo contenente solo se stesso e scarica i KeyPackage per B e C. Per ogni membro, A genera una proposta di aggiunta e un messaggio di impegno per aggiungere quel membro e poi trasmette i due messaggi al gruppo. Il client A genera anche un messaggio di benvenuto e lo invia direttamente al nuovo membro (non è necessario inviarlo al gruppo). Solo dopo che A ha ricevuto il messaggio Commit dal Delivery Service, aggiorna il suo stato per riflettere l'aggiunta del nuovo membro. Una volta che A ha aggiornato il suo stato, il nuovo membro ha elaborato il Welcome e tutti gli altri membri del gruppo hanno elaborato il Commit, tutti avranno rappresentazioni coerenti dello stato del gruppo, compreso un segreto di gruppo che è noto solo ai membri del gruppo. Il nuovo membro potrà leggere e inviare nuovi messaggi al gruppo, ma i messaggi inviati prima dell'aggiunta al gruppo non saranno accessibili.
  - Per garantire la segretezza in avanti e la sicurezza post-compromissione dei messaggi, ogni membro aggiorna periodicamente le chiavi che lo rappresentano nel gruppo. Un membro lo fa inviando un Commit (eventualmente senza proposte) o inviando un messaggio Update che viene impegnato da un altro membro (vedi Figura 4). Una volta che gli altri membri del gruppo hanno elaborato questi messaggi, i segreti del gruppo saranno sconosciuti a un attaccante che avesse compromesso i segreti corrispondenti alla foglia del mittente nell'albero. Alla fine dello scenario illustrato nella Figura 4, il gruppo ha una sicurezza post-compromissione sia per quanto riguarda A che per B.
  - I messaggi di aggiornamento DOVREBBERO essere inviati a intervalli regolari finché il gruppo è attivo e i membri che non si aggiornano DOVREBBERO essere rimossi dal gruppo. Spetta all'applicazione determinare un intervallo di tempo appropriato tra un aggiornamento e l'altro. Poiché lo scopo dell'invio di un aggiornamento è quello di limitare in modo proattivo una finestra di compromesso, la frequenza giusta è solitamente dell'ordine di ore o giorni, non di millisecondi. Ad esempio, un'applicazione potrebbe inviare un aggiornamento ogni volta che un membro invia un messaggio di applicazione dopo aver ricevuto un messaggio da un altro membro, oppure ogni giorno se non vengono inviati messaggi di applicazione.

# TreeKEM
Gli alberi a cricchetto consentono a un gruppo di rimuovere in modo efficiente qualsiasi membro criptando nuova entropia a un sottoinsieme del gruppo. Un albero a cricchetto assegna le chiavi condivise a sottogruppi del gruppo complessivo, in modo che, ad esempio, la crittografia a tutti i membri del gruppo tranne uno richieda solo log(N) crittografie ai sottogruppi, invece delle N-1 crittografie che sarebbero necessarie per crittografare ogni singolo partecipante (dove N è il numero di membri del gruppo). Per calcolare le chiavi di gruppo, è necessario assegnare a ogni nodo dell'albero una coppia di chiavi nota solo ai membri del gruppo, cioè ai dispositivi che appaiono come foglie nel sottoalbero corrente. In una foglia, generiamo coppie di chiavi KEM fresche per ogni dispositivo (chiave segreta(d_i), chiave pubblica(d_i)). Per ogni nodo interno, la chiave segreta viene calcolata come hash della chiave segreta di uno dei due figli, intuitivamente l'ultimo figlio che ha effettuato un'operazione di gruppo. La chiave di autenticazione per la cifratura del gruppo di messaggistica (encryption key(d_j)) è derivata (come una catena di invocazioni KDF) dalla sequenza di chiavi alla radice dell'albero. In TreeKEM, quindi, le chiavi interne dei nodi dipendono solo da uno dei due figli.

##### Concurrent operations
La proprietà chiave di TreeKEM è che la maggior parte delle operazioni sono “unificabili”, nel senso che qualsiasi dispositivo che riceva due operazioni concorrenti sarà in grado di elaborarle ed eseguirle entrambe senza doverne rifiutare una o chiedere ulteriori informazioni. Poiché entrambi gli aggiornamenti sono stati emessi rispetto al vecchio stato globale, tuttavia, il nuovo albero non è ancora completamente aggiornato, nel senso che un aggressore che conosce le vecchie chiavi di A e D è in grado di calcolare la nuova chiave di gruppo, questo poiché H2(D′) e H2(A′) sono state inviate cifrate alle vecchie chiavi pubbliche di A e D. TreeKEM consente l'esecuzione immediata degli aggiornamenti concorrenti, ma i vantaggi della sicurezza post-compromissione non si applicano fino a quando non viene emesso un altro aggiornamento sullo stato unito. Poiché l'elaborazione di un aggiornamento comporta la sovrascrittura delle chiavi, affinché gli aggiornamenti concorrenti funzionino correttamente, le implementazioni devono conservare un insieme di chiavi storiche in modo da poter elaborare gli aggiornamenti inviati sulla base dello stesso stato iniziale Sk. Questo è compatibile con diversi algoritmi di conservazione dello stato, a patto che le implementazioni concordino su quali aggiornamenti debbano essere elaborati e quali rifiutati (e quindi quando le chiavi possono essere scartate). Dopo aver elaborato gli aggiornamenti contemporanei dei dispositivi A e D, il dispositivo B invia un nuovo aggiornamento. Questo aggiornamento si propaga lungo l'albero, “curando” così tutti i nodi dell'albero in uno stato unito coerente. Una volta elaborato il nuovo aggiornamento, si ottiene una PCS contro la compromissione di tutti i dispositivi; in altre parole, un avversario che compromette i vecchi stati di A, B e D non può più calcolare la nuova chiave di gruppo.

# TreeDEM
Il TreeDEM è il sottoprotocollo che permette ai partecipanti di un gruppo di scambiare messaggi garantendo forward security. Per farlo utilizza una chiave di gruppo  che viene fornita dal TreeKEM. Dato un epoch secret, il protocollo TreeDEM deriva le chiavi di cifratura dei messaggi per ogni membro del gruppo corrente e specifica come queste vengono utilizzate per inviare e ricevere messaggi di applicazione, messaggi di handshake (contenenti proposte e commit di TreeKEM) e messaggi di benvenuto per i nuovi membri. Descriviamo brevemente come TreeDEM autentica e cripta i messaggi applicativi. Ogni messaggio applicativo viene serializzato in una stringa di bit insieme a metadati che indicano il gruppo, l'epoca e il mittente. Questa stringa di bit viene quindi firmata con la chiave di firma del mittente (riusciamo ad autenticare il mittente del messagio) e successivamente viene creato un tag sfruttando una funzione MAC usando come chiave quella derivata dall'attuale segreto epocale. Il messaggio serializzato, la sua firma e il MAC vengono quindi crittografati con uno schema di crittografia autenticata (AEAD) utilizzando la chiave di crittografia del messaggio corrente del mittente. Dopo l'invio o la ricezione di ogni messaggio, la chiave di crittografia del mittente viene aggiornata (o aumentata) utilizzando una funzione di derivazione della chiave per garantire la segretezza in avanti: la compromissione di un membro del gruppo dopo l'aggiornamento della chiave non rivela le chiavi precedenti o i messaggi crittografati con quelle chiavi. Ogni membro del gruppo deve tenere traccia delle chiavi di crittografia correnti di tutti i membri e aggiornarle a ogni messaggio di richiesta. In gruppi di grandi dimensioni, mantenere tutte queste chiavi può essere costoso, soprattutto se solo una piccola minoranza di membri invia messaggi in ogni epoca. Di conseguenza, TreeDEM utilizza una tecnica di derivazione delle chiavi dei messaggi basata su un albero che deriva lazely le chiavi per ogni mittente, per ridurre il numero di chiavi che ogni membro deve mantenere. 


# Key Schedule
Lo scopo del key schedule è quello di combinare il materiale eseitente con del nuovo materiale crittografico, nello specifico creare una catena rispetto le epoche tramite la chiave interna secret int. Il key schedule è in grado di combinare s_int con una chiave esterna S_ext, e il commit_secret kcs che è un valore derivato tramite il treeKEM. IL key schedule utilizza una KDF che è basata su un estrattore (XTR) e un blocco di espansione (XPD) seguendo HKDF standard. Il ks concatena due intere funzioni KDF e poi una singola XPD. Nel caso dell'entrata di un membro, quest'ultimo, tramite il welcome message avrà a disposizione solamente una chiave k_join e non la ks. 
Prima di essere utilizzato nell'operazione di crittografia, il nonce viene sottoposto a XOR con un nuovo valore casuale per evitare il riutilizzo. Poiché la key schedule genera nonce in modo deterministico, un client DEVE mantenere uno stato persistente che indichi in quale punto della key schedule si trova; se questo stato persistente viene perso o corrotto, un client potrebbe riutilizzare una generazione già utilizzata, causando il riutilizzo di una coppia chiave/nonce. Per evitare questa situazione, il mittente di un messaggio DEVE generare un nuovo valore casuale di quattro byte “reuse guard” e fare lo XOR con i primi quattro byte del nonce dalla key schedule prima di utilizzare il nonce per la crittografia. Il mittente DEVE includere il valore di reuse guard nel campo reuse_guard dell'oggetto dati del mittente, in modo che il destinatario del messaggio possa usarlo per calcolare il nonce da usare per la decifrazione.


# TreeSync
## Why?

> Mettendo caso che alice entri in un gruppo sicuro e riceva l'albero delle chiavi pubbliche, come fa ad essere sicura che queste chiavi non siano controllate da un attaccante? 

> Come fa ad essere sicura su chi sono i partecipanti del gruppo? Può un attaccante essere nel gruppo senza che lei lo sappia? Bob è davvero Bob o è qualcun'altro?

**TreeSync** punta a risolvere questi problemi andando ad autenticare gli stati del TreeKEM. Nello specifico:
- autentica tutte le chiavi pubbliche
- autenticare i **group membership agreement**
Prima dell'implementazione del TreeSync, MLS era soggetta a molte tipologie di attacchi di tipo Man-In-The-Middle, cosa che attualmente non sono praticabili.

Come descritto dallo standard [[Messaging Layer Security#TreeKEM]] nella descrizione formale dello stato locale di una foglia per ogni nodo dobbiamo conservare un nuovo valore che prende il nome di **parent hash** che verrà firmato con con la propria chiave pubblica.
Nel corso delle nostre spiegazioni, abbiamo sempre fatto riferimento alla necessità di un meccanismo in grado di proteggere l'integrità dell'intero albero, che i) tenga conto correttamente dei meccanismi delle foglie non sommerse e dei nodi vuoti e ii) soddisfi il vincolo che un aggiornamento del percorso possa modificare solo i nodi lungo il percorso. Questo meccanismo di integrità è noto come Parent Hash e deve soddisfare altri requisiti: in primo luogo, il numero di calcoli e ricomputazioni dell'hash deve essere minimo (per garantire l'efficienza); in secondo luogo, l'hash del genitore deve coprire il contenuto di tutti i sottoalberi che esistevano nell'albero quando l'hash del genitore è stato modificato per l'ultima volta.
**Calcolo**: Ogni nodo dell'albero memorizza un hash del genitore. Quando viene applicato un aggiornamento del percorso, l'hash del genitore di ogni nodo del percorso viene ricalcolato, partendo dalla radice e continuando fino alla foglia (partecipante) che ha emesso il percorso aggiornamento. Al termine dell'emissione dell'aggiornamento del percorso, la foglia firma il proprio hash del genitore. In questo modo, il partecipante firma (autentica) la propria appartenenza all'albero, così come il contenuto del proprio genitore P, l'intero albero dei fratelli S e qualsiasi altra cosa che l'hash del genitore di P copre ricorsivamente. Transitivamente, ciò significa che la foglia contiene un valore di hash che protegge l'integrità di ogni nodo, fratello e genitore, fino alla radice.
Questa firma serve ad attestare quali nodi sono a conoscenza delle chiavi segrete.


